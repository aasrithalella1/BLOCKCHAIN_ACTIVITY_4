<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Minimal DApp — DIDLab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 24px auto; padding: 0 12px; }
    h1 { margin-bottom: 4px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    input, button { padding: 8px 10px; font-size: 14px; }
    input { min-width: 320px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; margin: 12px 0; }
    .muted { color: #666; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .ok { color: #0b7; }
    .err { color: #b00; }
    .grid { display: grid; grid-template-columns: 160px 1fr; gap: 6px 10px; align-items: center; }
    .sep { height: 1px; background: #eee; margin: 12px 0; }
  </style>
</head>
<body>
  <h1>Minimal DApp</h1>
  <div class="muted">Connect to your DIDLab team chain, load your ERC-20, view balance, and transfer.</div>

  <div class="card" id="connectCard">
    <h3>1) Connect wallet</h3>
    <div class="row">
      <button id="connectBtn">Connect MetaMask</button>
      <button id="refreshBtn" disabled>Refresh</button>
    </div>
    <div class="grid" style="margin-top:10px;">
      <div>Account:</div><div class="mono" id="acct">—</div>
      <div>Network:</div><div class="mono" id="net">—</div>
    </div>
    <div id="connectMsg" class="muted"></div>
  </div>

  <div class="card" id="tokenCard">
    <h3>2) Load token</h3>
    <div class="row">
      <input id="tokenInput" placeholder="Paste ERC-20 token address (0x…)" />
      <button id="loadTokenBtn">Load Token</button>
      <button id="addAssetBtn" disabled>Add to MetaMask</button>
    </div>
    <div class="grid" style="margin-top:10px;">
      <div>Name:</div><div id="tName">—</div>
      <div>Symbol:</div><div id="tSymbol">—</div>
      <div>Decimals:</div><div id="tDecimals">—</div>
    </div>
    <div class="sep"></div>
    <div><b>Balance:</b> <span class="mono" id="balance">—</span></div>
    <div id="tokenMsg" class="muted"></div>
  </div>

  <div class="card" id="xferCard">
    <h3>3) Transfer</h3>
    <div class="row">
      <input id="toInput" placeholder="Recipient address (0x…)" />
      <input id="amtInput" placeholder="Human amount (e.g., 1.25)" />
      <button id="sendBtn" disabled>Send</button>
    </div>
    <div id="txArea" class="muted"></div>
  </div>

  <script type="module">
    import {
      createPublicClient, createWalletClient, http, custom,
      formatUnits, parseUnits, erc20Abi, isAddress
    } from "https://esm.sh/viem@2";

    // === TEAM CHAIN CONFIG — change if you're not Team 06 ===
    const TEAM = "06";
    const RPC_URL = "https://hh-06.didlab.org";
    const CHAIN_ID_DEC = 31342;
    const CHAIN_ID_HEX = "0x7a6e"; // 31342 in hex
    const CHAIN_NAME = `DIDLab Team ${TEAM}`;
    const NATIVE = { name: "Ether", symbol: "ETH", decimals: 18 };

    // Minimal chain object for Viem:
    const chain = {
      id: CHAIN_ID_DEC,
      name: CHAIN_NAME,
      nativeCurrency: NATIVE,
      rpcUrls: { default: { http: [RPC_URL] } }
    };

    // Viem clients: wallet uses MetaMask; public uses RPC (for stable reads/polling)
    const walletClient = createWalletClient({ chain, transport: custom(window.ethereum) });
    const publicClient = createPublicClient({ chain, transport: http(RPC_URL) });

    // UI elements
    const connectBtn = document.getElementById('connectBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const acctEl = document.getElementById('acct');
    const netEl = document.getElementById('net');
    const connectMsg = document.getElementById('connectMsg');

    const tokenInput = document.getElementById('tokenInput');
    const loadTokenBtn = document.getElementById('loadTokenBtn');
    const addAssetBtn = document.getElementById('addAssetBtn');
    const tNameEl = document.getElementById('tName');
    const tSymbolEl = document.getElementById('tSymbol');
    const tDecimalsEl = document.getElementById('tDecimals');
    const tokenMsg = document.getElementById('tokenMsg');
    const balanceEl = document.getElementById('balance');

    const toInput = document.getElementById('toInput');
    const amtInput = document.getElementById('amtInput');
    const sendBtn = document.getElementById('sendBtn');
    const txArea = document.getElementById('txArea');

    let currentAccount = null;
    let token = { address: null, name: null, symbol: null, decimals: null };
    let unwatchBlocks = null;

    // Persist last token
    const LS_KEY = "didlab_token_address";
    const saved = localStorage.getItem(LS_KEY);
    if (saved) tokenInput.value = saved;

    function uiStatus(el, msg, ok=false, err=false) {
      el.className = "muted" + (ok ? " ok" : "") + (err ? " err" : "");
      el.textContent = msg;
    }

    async function ensureChain() {
      const eth = window.ethereum;
      if (!eth) throw new Error("MetaMask not found. Install the extension.");
      // Try to switch; if unknown chain, add it.
      try {
        await eth.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: CHAIN_ID_HEX }],
        });
      } catch (e) {
        if (e?.code === 4902) {
          await eth.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: CHAIN_ID_HEX,
              chainName: CHAIN_NAME,
              rpcUrls: [RPC_URL],
              nativeCurrency: NATIVE,
            }],
          });
        } else {
          throw e;
        }
      }
    }

    async function connect() {
      try {
        await ensureChain();
        const [account] = await window.ethereum.request({ method: "eth_requestAccounts" });
        currentAccount = account;
        acctEl.textContent = account;
        netEl.textContent = `${CHAIN_NAME} (${CHAIN_ID_DEC}, ${CHAIN_ID_HEX})`;
        uiStatus(connectMsg, "Connected. You can now load a token.", true, false);
        refreshBtn.disabled = false;
        if (!unwatchBlocks) {
          unwatchBlocks = publicClient.watchBlockNumber({
            emitOnBegin: true,
            poll: true,
            onBlockNumber: () => { if (token.address && currentAccount) refreshBalance().catch(()=>{}); }
          });
        }
      } catch (e) {
        uiStatus(connectMsg, e.message || String(e), false, true);
      }
    }

    async function readTokenMeta(address) {
      const [name, symbol, decimals] = await Promise.all([
        publicClient.readContract({ address, abi: erc20Abi, functionName: "name" }),
        publicClient.readContract({ address, abi: erc20Abi, functionName: "symbol" }),
        publicClient.readContract({ address, abi: erc20Abi, functionName: "decimals" }),
      ]);
      return { name, symbol, decimals };
    }

    async function refreshBalance() {
      if (!token.address || !currentAccount) return;
      try {
        const raw = await publicClient.readContract({
          address: token.address,
          abi: erc20Abi,
          functionName: "balanceOf",
          args: [currentAccount],
        });
        balanceEl.textContent = `${formatUnits(raw, token.decimals)} ${token.symbol ?? ""}`;
      } catch (e) {
        balanceEl.textContent = "—";
        uiStatus(tokenMsg, e.message || String(e), false, true);
      }
    }

    async function loadToken() {
      try {
        uiStatus(tokenMsg, "Loading token…");
        const addr = tokenInput.value.trim();
        if (!isAddress(addr)) throw new Error("Invalid token address.");
        const meta = await readTokenMeta(addr);
        token = { address: addr, ...meta };
        tNameEl.textContent = token.name;
        tSymbolEl.textContent = token.symbol;
        tDecimalsEl.textContent = token.decimals;
        localStorage.setItem(LS_KEY, addr);
        addAssetBtn.disabled = false;
        sendBtn.disabled = !currentAccount;
        await refreshBalance();
        uiStatus(tokenMsg, "Token loaded.", true);
      } catch (e) {
        tNameEl.textContent = tSymbolEl.textContent = tDecimalsEl.textContent = "—";
        addAssetBtn.disabled = true;
        sendBtn.disabled = true;
        uiStatus(tokenMsg, e.message || String(e), false, true);
      }
    }

    async function addAsset() {
      try {
        if (!token.address) throw new Error("Load a token first.");
        await window.ethereum.request({
          method: "wallet_watchAsset",
          params: {
            type: "ERC20",
            options: {
              address: token.address,
              symbol: token.symbol,
              decimals: token.decimals,
            }
          }
        });
        uiStatus(tokenMsg, "Token added to MetaMask (Assets).", true);
      } catch (e) {
        uiStatus(tokenMsg, e.message || String(e), false, true);
      }
    }

    async function send() {
      try {
        txArea.textContent = "Sending…";
        if (!currentAccount) throw new Error("Connect first.");
        if (!token.address) throw new Error("Load a token first.");
        const to = toInput.value.trim();
        const amt = amtInput.value.trim();
        if (!isAddress(to)) throw new Error("Invalid recipient address.");
        if (!amt || Number.isNaN(Number(amt)) || Number(amt) <= 0) throw new Error("Enter a positive amount.");

        const amountUnits = parseUnits(amt, token.decimals);
        const hash = await walletClient.writeContract({
          address: token.address, abi: erc20Abi, functionName: "transfer", args: [to, amountUnits]
        });
        txArea.innerHTML = `Tx hash: <span class="mono">${hash}</span> (waiting to mine…)`;

        const receipt = await publicClient.waitForTransactionReceipt({ hash });
        const gasUsed = receipt.gasUsed;                  // BigInt
        const egp = receipt.effectiveGasPrice ?? 0n;      // BigInt (EIP-1559)
        const feeWei = gasUsed * egp;
        const feeEth = egp ? `${formatUnits(feeWei, 18)} ETH` : "—";

        txArea.innerHTML =
          `✅ Mined in block <b>${receipt.blockNumber}</b><br>` +
          `Hash: <span class="mono">${hash}</span><br>` +
          `Gas used: <span class="mono">${gasUsed}</span> | Effective fee: <span class="mono">${feeEth}</span>`;
        await refreshBalance();
      } catch (e) {
        txArea.innerHTML = `<span class="err">Error: ${e.message || String(e)}</span>`;
      }
    }

    // Events
    connectBtn.onclick = connect;
    refreshBtn.onclick = refreshBalance;
    loadTokenBtn.onclick = loadToken;
    addAssetBtn.onclick = addAsset;
    sendBtn.onclick = send;

    // MetaMask reactive updates
    if (window.ethereum) {
      window.ethereum.on?.("accountsChanged", (accs) => {
        currentAccount = accs?.[0] || null;
        acctEl.textContent = currentAccount || "—";
        refreshBtn.disabled = !currentAccount;
        sendBtn.disabled = !currentAccount;
        refreshBalance();
      });
      window.ethereum.on?.("chainChanged", async () => {
        try {
          await ensureChain();
          netEl.textContent = `${CHAIN_NAME} (${CHAIN_ID_DEC}, ${CHAIN_ID_HEX})`;
          refreshBalance();
        } catch (e) {
          uiStatus(connectMsg, e.message || String(e), false, true);
        }
      });
    }
  </script>
</body>
</html>
